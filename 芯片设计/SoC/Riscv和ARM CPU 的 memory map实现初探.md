# Riscv和ARM CPU 的 memory map实现初探

对于常见的32CPU来说，可以访问的地址空间一共有4G。但是在实际情况下，情况并没有这么简单，对于一些CPU来说存在着实际的限制。比如，在很多场景下，CPU会对可以访问的外部地址有一定的限制，同时预留一部分地址空间给CPU内部的寄存器，只会留出一部分地址空间留给外设。实际上，在很多时候，地址空间都是足够的。但是，在更多的时候CPU希望可以访问更大范围的地址空间。就像你在组装电脑的时候，CPU的位宽决定了最大内存的大小，但是并不妨碍你再买个3T的硬盘保存你的电影和游戏。
通常外设空间的大小远远超出了CPU可以直接访问的地址空间，如果想访问更大的地址空间，最简单的办法毫无疑问就是扩大CPU的位宽（不是），但是受制于实际成本，这样做并不现实，通常更常用的方式是使用一套额外的存储管理机制，牺牲一部分传输效率，换取访问更大存储空间的能力，毕竟直接提成CPU位宽的方式需要考虑到软件和总线的支持情况，外挂存储控制器实际上是一个更经济的方式。
下面初步介绍一下当前主流的解决方案，实际上我司也有一套方案，有别于riscv和ARM，不过不太方便拿出来说。

## mmp的发展历史
我之前带新人的时候经常对那些刚毕业的年轻人说的一句话就是，在学习任何一个技术的时候，都要时时刻刻搞清楚这个技术在设计之初是为了解决什么问题而存在的。~~(就像你只有充分理解A股被创作出来是为了解决什么问题的话，你就明白你应不应该炒股了。)~~ 同样的道理，只有了解了发展背景才能知道设计的原因，所以有必要了解一下MMU的发展历史。
在谈论地址空间之前，我觉得有必要先说一个基本概念，CPU在访问外部空间的时候，都是希望可以访问无穷大的地址。但是受限于
在传说时代，CPU可以访问的地址空间是受到位宽限制的。比如，在51单片机时代，CPU是8bit的，那么这个CPU可以直接访问的地址空间就是 2^8=256 Byte 地址区域也就是00H~FFH之间区域。但是仅仅256B的空间是远远不足以支持实际的需要，所以当时提出了间接访问的概念，就是把地址空间扩展一下。虽然CPU仍然是8bit的CPU，但是在访问地址的时候，除了直接访问00H ~ FFH之间地址

## ARM 和 MMU
